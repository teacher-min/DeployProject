## CI(Continuous Integration)     : 빌드와 테스트를 자동화 하는 과정
## CD(Continuous Delivery/Deploy) : CI 단계에서 통합된 코드를 실제 서비스 환경에 배포하는 과정

name: Docker Image CI/CD Pipeline

## event : main branch에 push, main branch에 pull request 할 때 동작
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

## env : 환경 변수 (job에서 사용할 수 있는 변수, ${{ env.환경변수 }})
env:
  DOCKER_IMAGE_NAME: DeployProject
  DOCKER_IMAGE_TAG: latest

## jobs : 작업 목록 (job > step)
jobs:
  ## 1. build (CI)
  build:
    ## 1) runs-on : 실행 환경 설정 (job을 실행할 OS)
    ##   ubuntu-latest == ubuntu-22.04 (2025년 기준)
    ##   github에서 제공하는 Github-hosted runners로 JDK, Docker, Maven, Gradle, Node.js 등이 사전 설치되어 있음
    ##   작업 디렉터리
    ##   /home/runner/
    ##    └── work/
    ##        └── DeployProject/          # 레파지토리명
    ##            └── DeployProject/      # 체크아웃된 소스코드 위치
    ##                ├── src/
    ##                ├── pom.xml
    ##                ├── Dockerfile
    ##                ├── .github/
    ##                │   └── workflows
    ##                │       └── cicd.yml
    ##                └── target/
    ##                    └── DeployProject.war
    runs-on: ubuntu-latest
    ## 2) steps : job을 구성하는 하위 동작
    steps:
      ## (1) github의 main branch 내려 받기
      - name: Checkout  ## 파이프라인에서 확인 가능한 이름(임의로 결정)
        uses: actions/checkout@v4  ## github actions에서 제공(actions)하는 checkout@v4 플러그인
        with:
          ref: main  ## main branch
      ## (2) JDK 설치 (원하는 JDK 설치를 위해서 필요함, JDK 설치 시 환경변수는 자동 설정되고 Maven의 JDK 버전을 맞춰 줌)
      - name: Setup JDK-11
        uses: actions/setup-java@v4
        with:
          java-version: "11"
          distribution: "temurin"
      ## (3) Maven Dependency 캐시
      - name: Cache Maven Dependency
        uses: actions/cache@v3
        with:
          path: ~/.m2  ## Maven Dependency 저장 위치
          key: ${{ runner.os }}-m2-${{ hashFiles("**/pom.xml") }}  ## 캐시 식별 키 생성 (pom.xml 파일이 변하면 새로운 캐시 식별 키 생성. 예: Linux-m2-d4280aef)
          restore-keys: ${{ runner.os }}-m2  ## 캐시 대체 키 생성 (식별 키를 이용해 매칭 실패 시 Linux-m2로 시작하는 최근 캐시를 찾아서 복원)
      ## (4) Maven version 확인
      - name: Check Maven version
        run: mvn --version  ## run : 커맨드 직접 입력
      ## (5) Maven Build (첫 번째 빌드)
      ##     빌드 결과 DeployProject.war 파일은 Github runner의 파일 시스템에 생성
      ##     도커 이미지 빌드 전에 오류 발견이 가능
      - name: Build with Maven
        run: mvn clean package -DskipTests  ## 빌드 시 테스트 생략
      ## (6) DockerHub 로그인
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_PASSWORD }}
      ## (7) Docker Image Build (★ Dockerfile 실행 포인트)
      - name: Build Docker Image
        run: docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }} .
      ## (8) Docker Image Push (DockerHub에 올리기)
      - name: Push Docker Image
        run: docker image push ${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }}
  ## 2. deploy (CD)
  deploy:
    ## 1) needs : "build" job 성공 시 "deploy" job 실행
    needs: build
    ## 2) runs-on : 실행 환경 설정 (job을 실행할 OS)
    runs-on: ubuntu-latest
    ## 3) steps : job을 구성하는 하위 동작
    steps:
      ## EC2 배포
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            # 1. Docker 설치가 안 된 경우 도커 설치
            if ! command -v docker &> /dev/null; then
              sudo apt update
              sudo apt install -y docker.io
              sudo systemctl start docker
              sudo systemctl enable docker
              sudo usermod -aG docker ubuntu
              newgrp docker
            fi
            # 2. 기존 컨테이너 및 자원 정리
            docker stop app-container
            docker rm app-container
            docker system prune -f
            # 3. 업로드 디렉터리 생성
            mkdir /home/ubuntu/upload
            # 4. 컨테이너 실행
            docker run -d \
              --name app-container \
              -p 8080:8080 \
              -v /home/ubuntu/upload:/myapp/upload \
              ${{ secrets.DOCKER_HUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.DOCKER_IMAGE_TAG }}